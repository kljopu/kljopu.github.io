---
title: "도메인 주도 설계 철저 입문 2"
categories:
  - Domain_Driven_Design
tags:
  - 객체지향, 도메인 주도 설계
date: "2021-11-11 22:00:14"
last_modified_at: "2021-11-11 22:00:14 +0800"
toc: true
toc_sticky: true
toc_label: Table of Contents
---

**2장 시스템 특유의 값을 나타내기 위한 '값 객체'**
{: .notice--warning}

### 2.1 값 객체란?

> 시스템 특유의 값을 표현하기 위해 정의하는 객체

ex)
<br>

```tsx
var fullName = "한준수";
colsole.log(fullName); // "한준수"라는 값을 출력
var lastName = fullName.sbstring(0, 1);
console.log(lastName); // "한"이 출력된다.
```

위 코드의 문제점은 뭘까?
만약 유저가 성이 먼저가 아닌 이름을 먼저 입력한다면 lastName에 이름이 할당 될 것입니다.

이런 문제를 해결하기 위해서 객체 지향 프로그래밍에서는 일반저으로 클래스를 사용합니다.

```tsx
Class FullName {
    constructor (
        firstName: string,
        lastName: string,
    ) {
        this.fullName = fullName;
        this.lastName = lastName;
    }
    public firstName: string;
    public lastName: string;
}
```

여기서 FullName 클래스는 이 시스템의 필요에 맞는 성명을 나타냅니다.
객체이기도 하고 동시에 값이기도 합니다. 따라서 이를 `값 객체`라고 합니다.

### 2.2 값의 성질과 값 객체 구현

<br>

값의 성질을 아는 것은 값 객체를 이해하기 위해 중요합니다.
값의 성질은 크게 세가지가 있습니다.

- 변하지 않는다.
- 주고 받을 수 있다.
- 등가성을 비교할 수 있다.

#### 2.2.1 값의 불변성

<br>

값은 변화하지 않는 성질을 갖습니다.
그렇다면 우리가 코딩을 할 때 수도 없이 수정하는 변수들은 그럼 값이 아닌가?

우리가 프로그래밍을 할때 값을 수정할 때는 새로운 값을 대입합니다.

그런데 사실 대입은 값을 수정하는 과정이 아닙니다. 대입을 통해 수정되는 것은 변수의 내용이지, 값 자체가 수정되는 것은 아닙니다.

```tsx
var greet = "안녕하세요";
geet.changeTo("Hello"); //예를 들어 이런 함수가 있다면
console.log(geet); // Hello 출력
```

<br>

위 코드를 보면 geet이라는 변수 선언과 동시에 `안녕하세요`라는 값이 대입됩니다.
그 다음에 geet의 값이 `Hello`라는 값으로 수정됩니다.
즉, 위 코드는 말 그대로 `값을 수정하는` 코드입니다.

<br>

이렇게 된다면 개발자는 많은 혼란을 일으키게 됩니다. 값은 변하면 안되기 때문입니다.

즉, FullName 클래스는 값 객체로서 변하지 않아야 하며, 값을 수정하는 기능을 제공하는 메서드는

정의되어선 안됩니다.

<br>

#### 2.2.2 교환 가능하다

<br>

값이 불변일지라도 값을 절대 수정해서는 안된다는 말은 아닙니다. (모순 처럼 들리지만 좀만 참고 읽어보자.)

**_우리가 평소에 값을 수정하는 방법_**

```tsx
// 숫자값 수정
var num = 0;
num = 1;

// 문자값 수정
var c = "0";
c = "b";

// 문자열 값 수정
var geet = "안녕하세요";
geet = "hello";
```

위의 코드는 모두 변수에 값을 대입하는 코드입니다. 즉, 대입문 자체가 값을 수정하는 방법입니다.

위와 같이 값 객체 또한 대입문을 통해 교환의 형식으로 표현됩니다.

```tsx
var fullName = new FullName("Han", "Junsu");
fullName = new FullName("Han", "Kyle");
```

> 값 객체는 불변이기 때문에 대입문을 통한 교환 외의 수단으로는 수정을 나타낼 수 없다.

#### 2.2.3 등가성 비교 가능

<br>

프로그래밍의 세계에서 같은 종류의 값끼리는 비교가 가능합니다.
예를 들어

```tsx
var num1 = 0;
var num2 = 0;
console.log(num1 === num2); // true
```

위의 코드에서 `num1`와 `num2`는 서로 별개의 인스턴스지만 값은 같은 것으로 취급됩니다.

이처럼 값객체도 값 객체를 구성하는 속성(변수)를 통해 비교됩니다.

**_값 객체간 비교_**

```tsx
var nameA = new FullName("Han", "Junsu");
var nameB = new FullName("Han", "Junsu");

console.log(nameA.equals(nameB)); //equals는 두 객체 값을 비교하는 function
// 값이 같을경우 true 리턴
```

**_속성값을 직접 깨내 비교_**

```tsx
var nameA = new FullName("Han", "Junsu");
var nameB = new FullName("Han", "Junsu");

var isEquals =
  nameA.firstName === nameB.firstName && nameA.lastName === nameB.lastName;

console.log(isEquals);
```

하지만 위의 방식은 잘못된 방식입니다.
생각해보면 값의 값을 꺼내어 비교한다는 행위 자체가 부자연스럽기 때문입니다.

따라서 값 객체는 값 객체 내부에 값 객체를 비교하는 메서드를 제공하여
비교를 진행하는게 자연스럽습니다.

<br>

이렇게 비교 함수를 값 객체 내부에 두면 여러가지 이점이 있습니다.

**속성을 추가해도 수정이 필요 없다**
